<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[DOM事件流&&事件处理程序]]></title>
      <url>%2F2017%2F02%2F12%2FBlog2%2F</url>
      <content type="text"><![CDATA[定义： 事件：用户或浏览器自身执行的某种动作。（click,load,mouseover） 事件流：从页面中接收事件的顺序，也可理解为事件在页面中传播的顺序。 事件处理程序：响应某个事件的函数。均以on开头。（onclick,onmouseover等） 1.事件流事件流分成两种：事件冒泡和事件捕获： IE的事件流叫做事件冒泡，即事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。 事件捕获的思想恰恰相反：不太具体的节点应该更早接收到事件，而最具体的节点应该最后接收到事件。(在事件达到预定目标之前捕获它) DOM事件流“DOM2级事件”规定的事件流包括三个阶段：事件捕获阶段，处于目标阶段和事件冒泡阶段。首先发生的是事件捕获阶段，为截获事件提供了机会。然后是实际的目标接收事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件作出相应。 以上图为例，单击div会按照图上显示的顺序触发事件。 浏览器支持 IE9，safari，chrome等目前均支持事件捕获的事件流类型，这些浏览器都是从windows对象开始捕获事件的。 大多数情况下，都是将事件处理程序添加到事件流的冒泡阶段，这样可以最大限度地兼容浏览器。（IE8及更早版本不支持时间捕获）如果不是特别需要，不建议在事件捕获阶段注册事件处理程序。 IE9，Opera,Firefox,Chrome 和 Safari都支持DOM事件流，IE8及更早版本不支持DOM事件流。 例子addEventListener在写例子之前，先简单介绍一个方法：addEventListener 该方法是‘DOM2级事件处理程序’的方法，它接受三个参数：要处理的事件名，作为事件处理程序的函数和一个布尔值 布尔值为false代表在冒泡阶段调用事件处理程序，true代表在捕获阶段调用事件处理程序 比如：btn.addEventListener(“click”,function(){alert(“Hello world”)},false) 就代表给按钮btn注册一个事件，当被点击时浏览器会弹出消息“Hello World”，并且在冒泡阶段调用click。 比较事件冒泡和事件捕获接下来就用addEventListener来展示事件冒泡和事件捕获的区别：先放上html 和 css 代码：12345&lt;div id="level1"&gt; &lt;div id="level2"&gt; &lt;div id="level3"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011121314151617#level1&#123; background:red; height:200px; width:200px;&#125; #level2&#123; background:orange; height:100px; width:100px;&#125; #level3&#123; background:yellow; height:50px; width:50px;&#125; 呈现的效果很简单，就是三个不同颜色的div块： 然后用JS给每一个div注册一个点击事件，为了更加直观，当每一个div的点击事件被触发时，会显示一条该div块背景颜色的消息，这样我们就能清楚地看到各个div的click事件被触发的先后顺序123456789101112131415var level1=document.getElementById('level1');var level2=document.getElementById('level2');var level3=document.getElementById('level3');level.addEventListener('click',function()&#123; alert('yellow');&#125;,false);leve2.addEventListener('click',function()&#123; alert('orange');&#125;,false);leve3.addEventListener('click',function()&#123; alert('red');&#125;,false); 根据上面的例子，addEventListener的布尔值参数被设置为false，所以会在冒泡阶段调用事件处理程序。当点击黄色方块后，会先后弹出消息”yellow”,”orange”,”red”；点击橙色方块后，会弹出消息”orange”,”red”；点击红色方块后，会弹出”red”.这个结果也印证了我们之前所说的事件冒泡会使事件开始时由最具体的元素接受，然后逐级向上传播到较为不具体的节点。这里的黄色方块是嵌套在最里面的div块，所以是该例子中最具体的节点，红色块是最外层的div快，在该例中是最不具体的节点。 接着我们再测试一下用事件捕获的思想会获得什么结果：html和css代码都不需要变动，只需要对JS代码稍作修改:把布尔值从false改成true.123456789101112131415var level1=document.getElementById('level1');var level2=document.getElementById('level2');var level3=document.getElementById('level3');level.addEventListener('click',function()&#123; alert('yellow');&#125;,true);leve2.addEventListener('click',function()&#123; alert('orange');&#125;,true);leve3.addEventListener('click',function()&#123; alert('red');&#125;,true); 结果还是和我们预想的一样，当点击黄色方块后，会先后弹出消息”red”,”orange”,”yellow”;当点击橙色方块后，会先后弹出消息”red”,”orange”；点击红色方块时仍然只有”red”.结果和上例恰好相反。 从上述两个例子，我们可以清晰地看出事件冒泡和事件捕获两种事件流的区别。 事件处理程序4种为事件指定处理程序的方式： HTML 事件处理程序： 1&lt;input type="button" value="click" onclick="showMsg()"/&gt; 1234567891011 function showMsg()&#123; alert("hello world"); &#125;``` * DOM0级事件处理程序：``` Javascript btn.onclick=function()&#123; alert("hello world"); &#125;; DOM2级事件处理程序： 12btn.addEventListener("click",function()&#123;&#125;,false); //事件冒泡btn.addEventListener("click",function()&#123;&#125;,true); //事件捕获 IE事件处理程序 通过attachEvent（）添加的事件处理程序会被添加到冒泡阶段。 使用attachEvent（）方法的情况下，事件处理程序会在全局作用域中运行，因此this等于window。 123btn.attachEvent("onclick",function()&#123; alert("hello world");&#125;); 参考 Javascript高级程序设计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript学习笔记(1) 作用域详解]]></title>
      <url>%2F2017%2F02%2F05%2FBlog1%2F</url>
      <content type="text"><![CDATA[JavaScript 作用域详解到现在已经学了将近一个月的JS了，对一个不折不扣的新手来说，感觉弄清楚作用域对于学习JS极其重要，所以我的第一篇blog主题就是JS作用域详解。如果文中有错误的地方，欢迎指正！ 作用域链与执行环境什么是执行环境： 执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个函数都有自己的执行环境。 什么是作用域链：作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。 先来看一个简单例子：1234567891011121314151617var name="lucy";function changePerson()&#123; var gender=null; if(name==="lucy")&#123; name="david"; gender="male"; &#125;else&#123; name="lucy"; gender="lady"; &#125;&#125;changePerson();alert("name is "+name); //name is davidalert("gender is "+ gender); //Uncaught ReferenceError: gender is not defined 这里changeName()的作用域包含两个对象：arguments对象和全局环境对象。changeName()之所以可以在函数内部访问变量color和gender，是因为可以在这个作用域链中找到它。 以上代码共涉及两个执行环境：全局环境和changePerson()的局部环境。全局环境中有一个变量name和两个函数:changePerson(),alert().changePerson()的局部环境中有一个变量gender。因为gender 被定义在changePerson()的局部环境中，全局环境无法访问到它，所以报错，而name可以被访问到是因为它本身就存在于全局环境中。 这里还要指出一个可能犯错的地方：123456789101112131415161718var name="lucy";function changePerson()&#123; gender=null; if(name==="lucy")&#123; name="david"; gender="male"; &#125;else&#123; name="lucy"; gender="lady"; &#125;&#125;changePerson();alert("name is "+name); //name is davidalert("gender is "+ gender); //gender is male 也行你可能会问，为什么这里gender就可以被访问到了呢？其实这两块代码非常相似，唯一的区别就是这次我特意漏写了gender之前的var，因为没有使用关键词var，所以gender被定义成了全局变量，那么自然也就能被alert()访问到了。当然故意这么做是不被提倡的，建议如果确实要定义一个全局变量的话，显示地定义在window对象上，因为在web浏览器中，全局执行环境被认为是window对象。 综上，我们可以得出：内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数 JavaScript的块级作用域什么是块级作用域 任何一对花括号({})中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。 比如我们用Java写一个最简单的for循环:12345for(int i=0;i&lt;5;i++)&#123; //do something&#125;System.out.println(i); //编译器无法找到i，因为i被定义在一个不可见的代码块内 JavaScript中没有块级作用域当上述的例子用JavaScript来写时：12345for(var i=0;i&lt;5;i++)&#123; //do something&#125;alert(i); //5 可以看到答案是5，也就是成功的得到了i的值，因为JS没有块级作用域，所以其实上面代码的效果等同于：123456var i=0;for(i=0;i&lt;5;i++)&#123; //do something&#125;alert(i); //5 （毫无疑问，结果是相同的） 块级作用域的作用从我们上述的例子来看，如果没有块级作用域，对于刚接触JS的新手来说，一不小心就可能会声明很多全局变量，这时候便会发生变量名冲突等问题。而在Java和C中我们并不用担心这一点。 参考 IcyFox Javascript高级程序设计]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[My first post]]></title>
      <url>%2F2017%2F01%2F30%2FMy-first-post%2F</url>
      <content type="text"><![CDATA[1System.out.println("Hello World");]]></content>
    </entry>

    
  
  
</search>
